-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Dphones.InputObject exposing (..)

import Dphones.Enum.Cursor_ordering
import Dphones.Enum.Mixen_constraint
import Dphones.Enum.Mixen_update_column
import Dphones.Enum.Order_by
import Dphones.Enum.Set_constraint
import Dphones.Enum.Set_update_column
import Dphones.Interface
import Dphones.Object
import Dphones.Scalar
import Dphones.ScalarCodecs
import Dphones.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildDate_comparison_exp :
    (Date_comparison_expOptionalFields -> Date_comparison_expOptionalFields)
    -> Date_comparison_exp
buildDate_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Date_comparison_expOptionalFields =
    { eq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , in_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , lte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , neq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , nin_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    }


{-| Type for the Date\_comparison\_exp input object.
-}
type alias Date_comparison_exp =
    { eq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , gte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , in_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Dphones.ScalarCodecs.Date
    , lte_ : OptionalArgument Dphones.ScalarCodecs.Date
    , neq_ : OptionalArgument Dphones.ScalarCodecs.Date
    , nin_ : OptionalArgument (List Dphones.ScalarCodecs.Date)
    }


{-| Encode a Date\_comparison\_exp into a value that can be used as an argument.
-}
encodeDate_comparison_exp : Date_comparison_exp -> Value
encodeDate_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.eq_ ), ( "_gt", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gt_ ), ( "_gte", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.gte_ ), ( "_in", ((Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lt_ ), ( "_lte", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.lte_ ), ( "_neq", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.neq_ ), ( "_nin", ((Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildInt_comparison_exp :
    (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields)
    -> Int_comparison_exp
buildInt_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, in_ = optionals____.in_, is_null_ = optionals____.is_null_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nin_ = optionals____.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input____.eq_ ), ( "_gt", Encode.int |> Encode.optional input____.gt_ ), ( "_gte", Encode.int |> Encode.optional input____.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input____.in_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_lt", Encode.int |> Encode.optional input____.lt_ ), ( "_lte", Encode.int |> Encode.optional input____.lte_ ), ( "_neq", Encode.int |> Encode.optional input____.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input____.nin_ ) ]


buildMixen_bool_exp :
    (Mixen_bool_expOptionalFields -> Mixen_bool_expOptionalFields)
    -> Mixen_bool_exp
buildMixen_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    Mixen_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_bool_expOptionalFields =
    { and_ : OptionalArgument (List Mixen_bool_exp)
    , not_ : OptionalArgument Mixen_bool_exp
    , or_ : OptionalArgument (List Mixen_bool_exp)
    , index : OptionalArgument Int_comparison_exp
    , list : OptionalArgument String_comparison_exp
    , plays : OptionalArgument Int_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , url : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Mixen_bool_exp` attributes. Note that this type
needs to use the `Mixen_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_bool_expRaw =
    { and_ : OptionalArgument (List Mixen_bool_exp)
    , not_ : OptionalArgument Mixen_bool_exp
    , or_ : OptionalArgument (List Mixen_bool_exp)
    , index : OptionalArgument Int_comparison_exp
    , list : OptionalArgument String_comparison_exp
    , plays : OptionalArgument Int_comparison_exp
    , title : OptionalArgument String_comparison_exp
    , url : OptionalArgument String_comparison_exp
    }


{-| Type for the Mixen\_bool\_exp input object.
-}
type Mixen_bool_exp
    = Mixen_bool_exp Mixen_bool_expRaw


{-| Encode a Mixen\_bool\_exp into a value that can be used as an argument.
-}
encodeMixen_bool_exp : Mixen_bool_exp -> Value
encodeMixen_bool_exp (Mixen_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeMixen_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeMixen_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeMixen_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "index", encodeInt_comparison_exp |> Encode.optional input____.index ), ( "list", encodeString_comparison_exp |> Encode.optional input____.list ), ( "plays", encodeInt_comparison_exp |> Encode.optional input____.plays ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ), ( "url", encodeString_comparison_exp |> Encode.optional input____.url ) ]


buildMixen_inc_input :
    (Mixen_inc_inputOptionalFields -> Mixen_inc_inputOptionalFields)
    -> Mixen_inc_input
buildMixen_inc_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, plays = Absent }
    in
    { index = optionals____.index, plays = optionals____.plays }


type alias Mixen_inc_inputOptionalFields =
    { index : OptionalArgument Int
    , plays : OptionalArgument Int
    }


{-| Type for the Mixen\_inc\_input input object.
-}
type alias Mixen_inc_input =
    { index : OptionalArgument Int
    , plays : OptionalArgument Int
    }


{-| Encode a Mixen\_inc\_input into a value that can be used as an argument.
-}
encodeMixen_inc_input : Mixen_inc_input -> Value
encodeMixen_inc_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "plays", Encode.int |> Encode.optional input____.plays ) ]


buildMixen_insert_input :
    (Mixen_insert_inputOptionalFields -> Mixen_insert_inputOptionalFields)
    -> Mixen_insert_input
buildMixen_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_insert_inputOptionalFields =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Mixen\_insert\_input input object.
-}
type alias Mixen_insert_input =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Mixen\_insert\_input into a value that can be used as an argument.
-}
encodeMixen_insert_input : Mixen_insert_input -> Value
encodeMixen_insert_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "list", Encode.string |> Encode.optional input____.list ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildMixen_on_conflict :
    Mixen_on_conflictRequiredFields
    -> (Mixen_on_conflictOptionalFields -> Mixen_on_conflictOptionalFields)
    -> Mixen_on_conflict
buildMixen_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Mixen_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Mixen_on_conflictRequiredFields =
    { constraint : Dphones.Enum.Mixen_constraint.Mixen_constraint
    , update_columns : List Dphones.Enum.Mixen_update_column.Mixen_update_column
    }


type alias Mixen_on_conflictOptionalFields =
    { where_ : OptionalArgument Mixen_bool_exp }


{-| Type alias for the `Mixen_on_conflict` attributes. Note that this type
needs to use the `Mixen_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_on_conflictRaw =
    { constraint : Dphones.Enum.Mixen_constraint.Mixen_constraint
    , update_columns : List Dphones.Enum.Mixen_update_column.Mixen_update_column
    , where_ : OptionalArgument Mixen_bool_exp
    }


{-| Type for the Mixen\_on\_conflict input object.
-}
type Mixen_on_conflict
    = Mixen_on_conflict Mixen_on_conflictRaw


{-| Encode a Mixen\_on\_conflict into a value that can be used as an argument.
-}
encodeMixen_on_conflict : Mixen_on_conflict -> Value
encodeMixen_on_conflict (Mixen_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Dphones.Enum.Mixen_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Dphones.Enum.Mixen_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeMixen_bool_exp |> Encode.optional input____.where_ ) ]


buildMixen_order_by :
    (Mixen_order_byOptionalFields -> Mixen_order_byOptionalFields)
    -> Mixen_order_by
buildMixen_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_order_byOptionalFields =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Mixen\_order\_by input object.
-}
type alias Mixen_order_by =
    { index : OptionalArgument Dphones.Enum.Order_by.Order_by
    , list : OptionalArgument Dphones.Enum.Order_by.Order_by
    , plays : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    , url : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Mixen\_order\_by into a value that can be used as an argument.
-}
encodeMixen_order_by : Mixen_order_by -> Value
encodeMixen_order_by input____ =
    Encode.maybeObject
        [ ( "index", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.index ), ( "list", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.list ), ( "plays", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.plays ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ), ( "url", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.url ) ]


buildMixen_pk_columns_input :
    Mixen_pk_columns_inputRequiredFields
    -> Mixen_pk_columns_input
buildMixen_pk_columns_input required____ =
    { url = required____.url }


type alias Mixen_pk_columns_inputRequiredFields =
    { url : String }


{-| Type for the Mixen\_pk\_columns\_input input object.
-}
type alias Mixen_pk_columns_input =
    { url : String }


{-| Encode a Mixen\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeMixen_pk_columns_input : Mixen_pk_columns_input -> Value
encodeMixen_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "url", Encode.string input____.url |> Just ) ]


buildMixen_set_input :
    (Mixen_set_inputOptionalFields -> Mixen_set_inputOptionalFields)
    -> Mixen_set_input
buildMixen_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_set_inputOptionalFields =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Mixen\_set\_input input object.
-}
type alias Mixen_set_input =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Mixen\_set\_input into a value that can be used as an argument.
-}
encodeMixen_set_input : Mixen_set_input -> Value
encodeMixen_set_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "list", Encode.string |> Encode.optional input____.list ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildMixen_stream_cursor_input :
    Mixen_stream_cursor_inputRequiredFields
    -> (Mixen_stream_cursor_inputOptionalFields -> Mixen_stream_cursor_inputOptionalFields)
    -> Mixen_stream_cursor_input
buildMixen_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Mixen_stream_cursor_inputRequiredFields =
    { initial_value : Mixen_stream_cursor_value_input }


type alias Mixen_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Mixen\_stream\_cursor\_input input object.
-}
type alias Mixen_stream_cursor_input =
    { initial_value : Mixen_stream_cursor_value_input
    , ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Mixen\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeMixen_stream_cursor_input : Mixen_stream_cursor_input -> Value
encodeMixen_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeMixen_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Dphones.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildMixen_stream_cursor_value_input :
    (Mixen_stream_cursor_value_inputOptionalFields -> Mixen_stream_cursor_value_inputOptionalFields)
    -> Mixen_stream_cursor_value_input
buildMixen_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { index = Absent, list = Absent, plays = Absent, title = Absent, url = Absent }
    in
    { index = optionals____.index, list = optionals____.list, plays = optionals____.plays, title = optionals____.title, url = optionals____.url }


type alias Mixen_stream_cursor_value_inputOptionalFields =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Type for the Mixen\_stream\_cursor\_value\_input input object.
-}
type alias Mixen_stream_cursor_value_input =
    { index : OptionalArgument Int
    , list : OptionalArgument String
    , plays : OptionalArgument Int
    , title : OptionalArgument String
    , url : OptionalArgument String
    }


{-| Encode a Mixen\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeMixen_stream_cursor_value_input : Mixen_stream_cursor_value_input -> Value
encodeMixen_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "index", Encode.int |> Encode.optional input____.index ), ( "list", Encode.string |> Encode.optional input____.list ), ( "plays", Encode.int |> Encode.optional input____.plays ), ( "title", Encode.string |> Encode.optional input____.title ), ( "url", Encode.string |> Encode.optional input____.url ) ]


buildMixen_updates :
    Mixen_updatesRequiredFields
    -> (Mixen_updatesOptionalFields -> Mixen_updatesOptionalFields)
    -> Mixen_updates
buildMixen_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { inc_ = Absent, set_ = Absent }
    in
    Mixen_updates { inc_ = optionals____.inc_, set_ = optionals____.set_, where_ = required____.where_ }


type alias Mixen_updatesRequiredFields =
    { where_ : Mixen_bool_exp }


type alias Mixen_updatesOptionalFields =
    { inc_ : OptionalArgument Mixen_inc_input
    , set_ : OptionalArgument Mixen_set_input
    }


{-| Type alias for the `Mixen_updates` attributes. Note that this type
needs to use the `Mixen_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Mixen_updatesRaw =
    { inc_ : OptionalArgument Mixen_inc_input
    , set_ : OptionalArgument Mixen_set_input
    , where_ : Mixen_bool_exp
    }


{-| Type for the Mixen\_updates input object.
-}
type Mixen_updates
    = Mixen_updates Mixen_updatesRaw


{-| Encode a Mixen\_updates into a value that can be used as an argument.
-}
encodeMixen_updates : Mixen_updates -> Value
encodeMixen_updates (Mixen_updates input____) =
    Encode.maybeObject
        [ ( "_inc", encodeMixen_inc_input |> Encode.optional input____.inc_ ), ( "_set", encodeMixen_set_input |> Encode.optional input____.set_ ), ( "where", encodeMixen_bool_exp input____.where_ |> Just ) ]


buildSet_bool_exp :
    (Set_bool_expOptionalFields -> Set_bool_expOptionalFields)
    -> Set_bool_exp
buildSet_bool_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { and_ = Absent, not_ = Absent, or_ = Absent, date = Absent, tag = Absent, title = Absent }
    in
    Set_bool_exp { and_ = optionals____.and_, not_ = optionals____.not_, or_ = optionals____.or_, date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_bool_expOptionalFields =
    { and_ : OptionalArgument (List Set_bool_exp)
    , not_ : OptionalArgument Set_bool_exp
    , or_ : OptionalArgument (List Set_bool_exp)
    , date : OptionalArgument Date_comparison_exp
    , tag : OptionalArgument String_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Set_bool_exp` attributes. Note that this type
needs to use the `Set_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_bool_expRaw =
    { and_ : OptionalArgument (List Set_bool_exp)
    , not_ : OptionalArgument Set_bool_exp
    , or_ : OptionalArgument (List Set_bool_exp)
    , date : OptionalArgument Date_comparison_exp
    , tag : OptionalArgument String_comparison_exp
    , title : OptionalArgument String_comparison_exp
    }


{-| Type for the Set\_bool\_exp input object.
-}
type Set_bool_exp
    = Set_bool_exp Set_bool_expRaw


{-| Encode a Set\_bool\_exp into a value that can be used as an argument.
-}
encodeSet_bool_exp : Set_bool_exp -> Value
encodeSet_bool_exp (Set_bool_exp input____) =
    Encode.maybeObject
        [ ( "_and", (encodeSet_bool_exp |> Encode.list) |> Encode.optional input____.and_ ), ( "_not", encodeSet_bool_exp |> Encode.optional input____.not_ ), ( "_or", (encodeSet_bool_exp |> Encode.list) |> Encode.optional input____.or_ ), ( "date", encodeDate_comparison_exp |> Encode.optional input____.date ), ( "tag", encodeString_comparison_exp |> Encode.optional input____.tag ), ( "title", encodeString_comparison_exp |> Encode.optional input____.title ) ]


buildSet_insert_input :
    (Set_insert_inputOptionalFields -> Set_insert_inputOptionalFields)
    -> Set_insert_input
buildSet_insert_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_insert_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Set\_insert\_input input object.
-}
type alias Set_insert_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Set\_insert\_input into a value that can be used as an argument.
-}
encodeSet_insert_input : Set_insert_input -> Value
encodeSet_insert_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildSet_on_conflict :
    Set_on_conflictRequiredFields
    -> (Set_on_conflictOptionalFields -> Set_on_conflictOptionalFields)
    -> Set_on_conflict
buildSet_on_conflict required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { where_ = Absent }
    in
    Set_on_conflict { constraint = required____.constraint, update_columns = required____.update_columns, where_ = optionals____.where_ }


type alias Set_on_conflictRequiredFields =
    { constraint : Dphones.Enum.Set_constraint.Set_constraint
    , update_columns : List Dphones.Enum.Set_update_column.Set_update_column
    }


type alias Set_on_conflictOptionalFields =
    { where_ : OptionalArgument Set_bool_exp }


{-| Type alias for the `Set_on_conflict` attributes. Note that this type
needs to use the `Set_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_on_conflictRaw =
    { constraint : Dphones.Enum.Set_constraint.Set_constraint
    , update_columns : List Dphones.Enum.Set_update_column.Set_update_column
    , where_ : OptionalArgument Set_bool_exp
    }


{-| Type for the Set\_on\_conflict input object.
-}
type Set_on_conflict
    = Set_on_conflict Set_on_conflictRaw


{-| Encode a Set\_on\_conflict into a value that can be used as an argument.
-}
encodeSet_on_conflict : Set_on_conflict -> Value
encodeSet_on_conflict (Set_on_conflict input____) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Dphones.Enum.Set_constraint.toString input____.constraint |> Just ), ( "update_columns", (Encode.enum Dphones.Enum.Set_update_column.toString |> Encode.list) input____.update_columns |> Just ), ( "where", encodeSet_bool_exp |> Encode.optional input____.where_ ) ]


buildSet_order_by :
    (Set_order_byOptionalFields -> Set_order_byOptionalFields)
    -> Set_order_by
buildSet_order_by fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_order_byOptionalFields =
    { date : OptionalArgument Dphones.Enum.Order_by.Order_by
    , tag : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Type for the Set\_order\_by input object.
-}
type alias Set_order_by =
    { date : OptionalArgument Dphones.Enum.Order_by.Order_by
    , tag : OptionalArgument Dphones.Enum.Order_by.Order_by
    , title : OptionalArgument Dphones.Enum.Order_by.Order_by
    }


{-| Encode a Set\_order\_by into a value that can be used as an argument.
-}
encodeSet_order_by : Set_order_by -> Value
encodeSet_order_by input____ =
    Encode.maybeObject
        [ ( "date", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.date ), ( "tag", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.tag ), ( "title", Encode.enum Dphones.Enum.Order_by.toString |> Encode.optional input____.title ) ]


buildSet_pk_columns_input :
    Set_pk_columns_inputRequiredFields
    -> Set_pk_columns_input
buildSet_pk_columns_input required____ =
    { tag = required____.tag }


type alias Set_pk_columns_inputRequiredFields =
    { tag : String }


{-| Type for the Set\_pk\_columns\_input input object.
-}
type alias Set_pk_columns_input =
    { tag : String }


{-| Encode a Set\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeSet_pk_columns_input : Set_pk_columns_input -> Value
encodeSet_pk_columns_input input____ =
    Encode.maybeObject
        [ ( "tag", Encode.string input____.tag |> Just ) ]


buildSet_set_input :
    (Set_set_inputOptionalFields -> Set_set_inputOptionalFields)
    -> Set_set_input
buildSet_set_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_set_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Set\_set\_input input object.
-}
type alias Set_set_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Set\_set\_input into a value that can be used as an argument.
-}
encodeSet_set_input : Set_set_input -> Value
encodeSet_set_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildSet_stream_cursor_input :
    Set_stream_cursor_inputRequiredFields
    -> (Set_stream_cursor_inputOptionalFields -> Set_stream_cursor_inputOptionalFields)
    -> Set_stream_cursor_input
buildSet_stream_cursor_input required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { ordering = Absent }
    in
    { initial_value = required____.initial_value, ordering = optionals____.ordering }


type alias Set_stream_cursor_inputRequiredFields =
    { initial_value : Set_stream_cursor_value_input }


type alias Set_stream_cursor_inputOptionalFields =
    { ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering }


{-| Type for the Set\_stream\_cursor\_input input object.
-}
type alias Set_stream_cursor_input =
    { initial_value : Set_stream_cursor_value_input
    , ordering : OptionalArgument Dphones.Enum.Cursor_ordering.Cursor_ordering
    }


{-| Encode a Set\_stream\_cursor\_input into a value that can be used as an argument.
-}
encodeSet_stream_cursor_input : Set_stream_cursor_input -> Value
encodeSet_stream_cursor_input input____ =
    Encode.maybeObject
        [ ( "initial_value", encodeSet_stream_cursor_value_input input____.initial_value |> Just ), ( "ordering", Encode.enum Dphones.Enum.Cursor_ordering.toString |> Encode.optional input____.ordering ) ]


buildSet_stream_cursor_value_input :
    (Set_stream_cursor_value_inputOptionalFields -> Set_stream_cursor_value_inputOptionalFields)
    -> Set_stream_cursor_value_input
buildSet_stream_cursor_value_input fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { date = Absent, tag = Absent, title = Absent }
    in
    { date = optionals____.date, tag = optionals____.tag, title = optionals____.title }


type alias Set_stream_cursor_value_inputOptionalFields =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Type for the Set\_stream\_cursor\_value\_input input object.
-}
type alias Set_stream_cursor_value_input =
    { date : OptionalArgument Dphones.ScalarCodecs.Date
    , tag : OptionalArgument String
    , title : OptionalArgument String
    }


{-| Encode a Set\_stream\_cursor\_value\_input into a value that can be used as an argument.
-}
encodeSet_stream_cursor_value_input : Set_stream_cursor_value_input -> Value
encodeSet_stream_cursor_value_input input____ =
    Encode.maybeObject
        [ ( "date", (Dphones.ScalarCodecs.codecs |> Dphones.Scalar.unwrapEncoder .codecDate) |> Encode.optional input____.date ), ( "tag", Encode.string |> Encode.optional input____.tag ), ( "title", Encode.string |> Encode.optional input____.title ) ]


buildSet_updates :
    Set_updatesRequiredFields
    -> (Set_updatesOptionalFields -> Set_updatesOptionalFields)
    -> Set_updates
buildSet_updates required____ fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { set_ = Absent }
    in
    Set_updates { set_ = optionals____.set_, where_ = required____.where_ }


type alias Set_updatesRequiredFields =
    { where_ : Set_bool_exp }


type alias Set_updatesOptionalFields =
    { set_ : OptionalArgument Set_set_input }


{-| Type alias for the `Set_updates` attributes. Note that this type
needs to use the `Set_updates` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Set_updatesRaw =
    { set_ : OptionalArgument Set_set_input
    , where_ : Set_bool_exp
    }


{-| Type for the Set\_updates input object.
-}
type Set_updates
    = Set_updates Set_updatesRaw


{-| Encode a Set\_updates into a value that can be used as an argument.
-}
encodeSet_updates : Set_updates -> Value
encodeSet_updates (Set_updates input____) =
    Encode.maybeObject
        [ ( "_set", encodeSet_set_input |> Encode.optional input____.set_ ), ( "where", encodeSet_bool_exp input____.where_ |> Just ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals____ =
    let
        optionals____ =
            fillOptionals____
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, iregex_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, niregex_ = Absent, nlike_ = Absent, nregex_ = Absent, nsimilar_ = Absent, regex_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals____.eq_, gt_ = optionals____.gt_, gte_ = optionals____.gte_, ilike_ = optionals____.ilike_, in_ = optionals____.in_, iregex_ = optionals____.iregex_, is_null_ = optionals____.is_null_, like_ = optionals____.like_, lt_ = optionals____.lt_, lte_ = optionals____.lte_, neq_ = optionals____.neq_, nilike_ = optionals____.nilike_, nin_ = optionals____.nin_, niregex_ = optionals____.niregex_, nlike_ = optionals____.nlike_, nregex_ = optionals____.nregex_, nsimilar_ = optionals____.nsimilar_, regex_ = optionals____.regex_, similar_ = optionals____.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , iregex_ : OptionalArgument String
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , niregex_ : OptionalArgument String
    , nlike_ : OptionalArgument String
    , nregex_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , regex_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input____ =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input____.eq_ ), ( "_gt", Encode.string |> Encode.optional input____.gt_ ), ( "_gte", Encode.string |> Encode.optional input____.gte_ ), ( "_ilike", Encode.string |> Encode.optional input____.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input____.in_ ), ( "_iregex", Encode.string |> Encode.optional input____.iregex_ ), ( "_is_null", Encode.bool |> Encode.optional input____.is_null_ ), ( "_like", Encode.string |> Encode.optional input____.like_ ), ( "_lt", Encode.string |> Encode.optional input____.lt_ ), ( "_lte", Encode.string |> Encode.optional input____.lte_ ), ( "_neq", Encode.string |> Encode.optional input____.neq_ ), ( "_nilike", Encode.string |> Encode.optional input____.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input____.nin_ ), ( "_niregex", Encode.string |> Encode.optional input____.niregex_ ), ( "_nlike", Encode.string |> Encode.optional input____.nlike_ ), ( "_nregex", Encode.string |> Encode.optional input____.nregex_ ), ( "_nsimilar", Encode.string |> Encode.optional input____.nsimilar_ ), ( "_regex", Encode.string |> Encode.optional input____.regex_ ), ( "_similar", Encode.string |> Encode.optional input____.similar_ ) ]
