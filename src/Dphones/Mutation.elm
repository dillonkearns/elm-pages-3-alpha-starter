-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Dphones.Mutation exposing (..)

import Dphones.InputObject
import Dphones.Interface
import Dphones.Object
import Dphones.Scalar
import Dphones.ScalarCodecs
import Dphones.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias DeleteMixenRequiredArguments =
    { where_ : Dphones.InputObject.Mixen_bool_exp }


{-| delete data from the table: "mixen"

  - where\_ - filter the rows which have to be deleted

-}
delete_mixen :
    DeleteMixenRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_mixen requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_mixen" [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeMixen_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteMixenByPkRequiredArguments =
    { url : String }


{-| delete single row from the table: "mixen"
-}
delete_mixen_by_pk :
    DeleteMixenByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_mixen_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_mixen_by_pk" [ Argument.required "url" requiredArgs____.url Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteSetRequiredArguments =
    { where_ : Dphones.InputObject.Set_bool_exp }


{-| delete data from the table: "set"

  - where\_ - filter the rows which have to be deleted

-}
delete_set :
    DeleteSetRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_set requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_set" [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeSet_bool_exp ] object____ (Basics.identity >> Decode.nullable)


type alias DeleteSetByPkRequiredArguments =
    { tag : String }


{-| delete single row from the table: "set"
-}
delete_set_by_pk :
    DeleteSetByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_set_by_pk requiredArgs____ object____ =
    Object.selectionForCompositeField "delete_set_by_pk" [ Argument.required "tag" requiredArgs____.tag Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias InsertMixenOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Mixen_on_conflict }


type alias InsertMixenRequiredArguments =
    { objects : List Dphones.InputObject.Mixen_insert_input }


{-| insert data into the table: "mixen"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_mixen :
    (InsertMixenOptionalArguments -> InsertMixenOptionalArguments)
    -> InsertMixenRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_mixen fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeMixen_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_mixen" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Dphones.InputObject.encodeMixen_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertMixenOneOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Mixen_on_conflict }


type alias InsertMixenOneRequiredArguments =
    { object : Dphones.InputObject.Mixen_insert_input }


{-| insert a single row into the table: "mixen"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_mixen_one :
    (InsertMixenOneOptionalArguments -> InsertMixenOneOptionalArguments)
    -> InsertMixenOneRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_mixen_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeMixen_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_mixen_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Dphones.InputObject.encodeMixen_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertSetOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Set_on_conflict }


type alias InsertSetRequiredArguments =
    { objects : List Dphones.InputObject.Set_insert_input }


{-| insert data into the table: "set"

  - objects - the rows to be inserted
  - on\_conflict - upsert condition

-}
insert_set :
    (InsertSetOptionalArguments -> InsertSetOptionalArguments)
    -> InsertSetRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_set fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeSet_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_set" (optionalArgs____ ++ [ Argument.required "objects" requiredArgs____.objects (Dphones.InputObject.encodeSet_insert_input |> Encode.list) ]) object____ (Basics.identity >> Decode.nullable)


type alias InsertSetOneOptionalArguments =
    { on_conflict : OptionalArgument Dphones.InputObject.Set_on_conflict }


type alias InsertSetOneRequiredArguments =
    { object : Dphones.InputObject.Set_insert_input }


{-| insert a single row into the table: "set"

  - object - the row to be inserted
  - on\_conflict - upsert condition

-}
insert_set_one :
    (InsertSetOneOptionalArguments -> InsertSetOneOptionalArguments)
    -> InsertSetOneRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_set_one fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { on_conflict = Absent }

        optionalArgs____ =
            [ Argument.optional "on_conflict" filledInOptionals____.on_conflict Dphones.InputObject.encodeSet_on_conflict ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "insert_set_one" (optionalArgs____ ++ [ Argument.required "object" requiredArgs____.object Dphones.InputObject.encodeSet_insert_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMixenOptionalArguments =
    { inc_ : OptionalArgument Dphones.InputObject.Mixen_inc_input
    , set_ : OptionalArgument Dphones.InputObject.Mixen_set_input
    }


type alias UpdateMixenRequiredArguments =
    { where_ : Dphones.InputObject.Mixen_bool_exp }


{-| update data of the table: "mixen"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_mixen :
    (UpdateMixenOptionalArguments -> UpdateMixenOptionalArguments)
    -> UpdateMixenRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_mixen fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Dphones.InputObject.encodeMixen_inc_input, Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeMixen_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_mixen" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeMixen_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMixenByPkOptionalArguments =
    { inc_ : OptionalArgument Dphones.InputObject.Mixen_inc_input
    , set_ : OptionalArgument Dphones.InputObject.Mixen_set_input
    }


type alias UpdateMixenByPkRequiredArguments =
    { pk_columns : Dphones.InputObject.Mixen_pk_columns_input }


{-| update single row of the table: "mixen"

  - inc\_ - increments the numeric columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_mixen_by_pk :
    (UpdateMixenByPkOptionalArguments -> UpdateMixenByPkOptionalArguments)
    -> UpdateMixenByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen
    -> SelectionSet (Maybe decodesTo) RootMutation
update_mixen_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { inc_ = Absent, set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_inc" filledInOptionals____.inc_ Dphones.InputObject.encodeMixen_inc_input, Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeMixen_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_mixen_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Dphones.InputObject.encodeMixen_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateMixenManyRequiredArguments =
    { updates : List Dphones.InputObject.Mixen_updates }


{-| update multiples rows of table: "mixen"

  - updates - updates to execute, in order

-}
update_mixen_many :
    UpdateMixenManyRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Mixen_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_mixen_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_mixen_many" [ Argument.required "updates" requiredArgs____.updates (Dphones.InputObject.encodeMixen_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)


type alias UpdateSetOptionalArguments =
    { set_ : OptionalArgument Dphones.InputObject.Set_set_input }


type alias UpdateSetRequiredArguments =
    { where_ : Dphones.InputObject.Set_bool_exp }


{-| update data of the table: "set"

  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_set :
    (UpdateSetOptionalArguments -> UpdateSetOptionalArguments)
    -> UpdateSetRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_set fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeSet_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_set" (optionalArgs____ ++ [ Argument.required "where" requiredArgs____.where_ Dphones.InputObject.encodeSet_bool_exp ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateSetByPkOptionalArguments =
    { set_ : OptionalArgument Dphones.InputObject.Set_set_input }


type alias UpdateSetByPkRequiredArguments =
    { pk_columns : Dphones.InputObject.Set_pk_columns_input }


{-| update single row of the table: "set"

  - set\_ - sets the columns of the filtered rows to the given values

-}
update_set_by_pk :
    (UpdateSetByPkOptionalArguments -> UpdateSetByPkOptionalArguments)
    -> UpdateSetByPkRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set
    -> SelectionSet (Maybe decodesTo) RootMutation
update_set_by_pk fillInOptionals____ requiredArgs____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { set_ = Absent }

        optionalArgs____ =
            [ Argument.optional "_set" filledInOptionals____.set_ Dphones.InputObject.encodeSet_set_input ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "update_set_by_pk" (optionalArgs____ ++ [ Argument.required "pk_columns" requiredArgs____.pk_columns Dphones.InputObject.encodeSet_pk_columns_input ]) object____ (Basics.identity >> Decode.nullable)


type alias UpdateSetManyRequiredArguments =
    { updates : List Dphones.InputObject.Set_updates }


{-| update multiples rows of table: "set"

  - updates - updates to execute, in order

-}
update_set_many :
    UpdateSetManyRequiredArguments
    -> SelectionSet decodesTo Dphones.Object.Set_mutation_response
    -> SelectionSet (Maybe (List (Maybe decodesTo))) RootMutation
update_set_many requiredArgs____ object____ =
    Object.selectionForCompositeField "update_set_many" [ Argument.required "updates" requiredArgs____.updates (Dphones.InputObject.encodeSet_updates |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list >> Decode.nullable)
